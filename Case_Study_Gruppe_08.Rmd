---
title: "Case_Study_Gruppe_08"
author: "Brayan Orjuela Pico, Chen Xue,  Tobias Königer, Xin Zhou,  Yue Zhang"
date: "März 1, 2020"
output: 
  html_document:
    toc: true
    theme: united
    number_sections: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

**Aufgabenstellung**

Wir sind Mitarbeiter eines fiktiven großen Automobilkonzerns, der unter zwei Automobilmarken, “OEM1” und “OEM2”, mehrere Fahrzeugtypen herstellt. Die Zulieferkette setzt sich aus zwei Instanzen zusammen: den Teilelieferanten und den Komponentenlieferanten. Das Produktionswerk verbaut die Komponenten in die jeweiligen Fahrzeuge. Momentan versuchen die Automobilhersteller, trotz negativer Berichterstattung über Dieselfahrzeuge, Kunden für Autos mit Dieselmotoren zu gewinnen. Ein oft verwendetes Argument ist **die Langlebigkeit von Dieselmotoren, die deutlich größer als die Lebensdauer der Benzinmotoren sein soll.**  Das Management beauftragt Sie, diese Behauptung zu überprüfen um mit der Aussage künftig werben zu können. Überprüfen Sie die Aussage über die Langlebigkeit von Dieselmotoren durch einen Vergleich mit Benzinmotoren. Überprüfen Sie die Aussage über die Langlebigkeit von Dieselmotoren durch einen Vergleich mit Benzinmotoren. Ermitteln Sie den Zeitraum zwischen Zulassungsdatum und Fehlerdatum aller Fahrzeuge, getrennt nach Motorisierungsart und Fahrzeugart. Visualisieren Sie Ihre Ergebnisse entsprechend Ihrer Zielgruppe. Ermöglichen Sie einen Vergleich zwischen den Fahrzeugtypen.

**Visualisierung**

A: Ein Balkendiagramm, das die relativen Fehlerhäufigkeiten aller Motoren, getrennt in Benzin- und Dieselantrieb, darstellt. Das Diagramm muss interaktive Elemente enthalten. Der Produktionszeitraum der Fahrzeuge muss durch den Nutzer variabel eingrenzbar sein.

B: Pro Fahrzeugtyp jeweils einen Boxplot für Varianten mit Dieselmotor und einen Boxplot für Varianten mit Benzinmotor. Die Boxplots beziehen sich dabei auf das Zeitintervall zwischen Zulassung eines Fahrzeugs und Fehlerdatum der Fahrzeuge. Wichtige Kennzahlen müssen interaktiv ablesbar sein. Die Fahrzeugtypen sollen an- und abwählbar sein. Alle Fahrzeugtypen von OEM1 und OEM2 sollen mit einem Klick an- und abwählbar sein. Der für das Balkendiagramm ausgewählte Produktionszeitraum soll auch hier angewendet werden.


# Laden und geg. Installieren notwendiger Bibliotheken

```{r packages, include=TRUE, message = FALSE}

if(!require(data.table)){
  install.packages("data.table")
}
# für die Verwendung von fread()
library(data.table)

if(!require(tidyverse)){
  install.packages("tidyverse")
}
library(tidyverse)

if(!require(shiny)){
  install.packages("shiny")
}
library(shiny)

if(!require(plyr)){
  install.packages("plyr")
}
library(plyr)

if(!require(lubridate)){
  install.packages("lubridate")
}
library(lubridate)

```


# Importieren der Daten

Aus die Aufgabenstellung gibt es solche Annahme:
$$
Lebensdauer=  Fehlerdatum - Zulassungsdatum
$$

## Relevante Daten

Zuerst wurde/wird es analysiert, welche daten relevant sind. Dieses Verfahren hängt von den folgenden drei Aufgaben und weiteren detallierten Anforderungen des Inhalts und der Eigenschaften der Shiny-Applikation. Darüber hinaus hängen die relevanten Daten mit den Dateien zusammen, die nicht nur die unterschiedlichen Motorentypen als ganze Systeme sondern auch die Einzelteile dieser Motoren beschreiben. 

1. Überprüfen Sie die Aussage über die Langlebigkeit von Dieselmotoren durch einen Vergleich mit Benzinmotoren.
2. Ermitteln Sie den Zeitraum zwischen Zulassungsdatum und Fehlerdatum aller Fahrzeuge, getrennt nach Motorisierungsart und Fahrzeugart.
3.  Visualisieren Sie Ihre Ergebnisse entsprechend Ihrer Zielgruppe. Ermöglichen Sie einen Vergleich zwischen den Fahrzeugtypen.


Die für die Analyse nötwendigen Parameter sind wie folgend aufgelistet :


- Fehlerdatum  der Fahrzeuge, die wegen eines fehlerhaften Motors, defekt geworden sind 
- Zulassungsdatum der oben geschriebenen Fahrzeuge
- Motorisierungsart dieser Fahrzeuge (Mit Diesel oder Benzin angetrieben) 
- Fahrzeugart(Typ11,Typ12, Typ21 oder Typ22)
- Fahrzeugmarke (OEM1 oder OEM2)
- Fehlermeldung aller Motoren (Fehlerhaft oder nicht) einschließlich Fehlermeldung ihrer Komponente 


| Nr.  | Faktoren                  | directory name       | file name                               | Spezifikation |
| ---- | ------------------------- | -------------------- | --------------------------------------- | ------------- |
| 1    | Zulassungsdatum           | "./Data/Zulassungen" | "Zulassungen_alle_Fahrzeuge.csv"        |               |
| 2    | Fehlerdatum der Fahrzeuge | "./Data/Fahrzeug"    | "Fahrzeuge_OEM1_Typ11.csv"              | Typ 11        |
| 3    |                           |                      | "Fahrzeuge_OEM1_Typ12.csv"              | Typ 12        |
| 4    |                           |                      | "Fahrzeuge_OEM2_Typ21.csv"              | Typ 21        |
| 5    |                           |                      | "Fahrzeuge_OEM2_Typ22.csv"              | Typ 22        |
| 6    | Motoren der Fahrzeuge     | "./Data/Fahrzeug"    | "Bestandteile_Fahrzeuge_OEM1_Typ11.csv" | Typ 11        |
| 7    |                           |                      | "Bestandteile_Fahrzeuge_OEM1_Typ12.csv" | Typ 12        |
| 8    |                           |                      | "Bestandteile_Fahrzeuge_OEM2_Typ21.csv" | Typ 21        |
| 9    |                           |                      | "Bestandteile_Fahrzeuge_OEM2_Typ22.csv" | Typ 22        |
| 10   | Fehlerdatum der Motoren   | "./Data/Komponente"  | "Komponente_K1BE1.csv"                  |               |
| 11   |                           |                      | "Komponente_K1BE2.csv"                  |               |
| 12   |                           |                      | "Komponente_K1DI1.csv"                  |               |
| 13   |                           |                      | "Komponente_K1DI2.txt"                  |               |
| 14   | Bestandteile der Motoren  | "./Data/Komponente"  | "Bestandteile_Komponente_K1BE1.csv"     |               |
| 15   |                           |                      | "Bestandteile_Komponente_K1BE2.csv"     |               |
| 16   |                           |                      | "Bestandteile_Komponente_K1DI1.csv"     |               |
| 17   |                           |                      | "Bestandteile_Komponente_K1DI2.csv"     |               |
| 18-28| Einzelteile der Motoren   | "./Data/Einzelteile" | "Einzelteil_T0X.txt"                    | X = 01 bis 10 |

# Einlesen der Daten 

**Einzelteile 01 bis 10**

Obwohl es 38 Einzelteile gibt, werden nur die Dateien mit Data zu den Einzelteilen 1-10 eingelesen, weil sie die Bestandteile der unterschiedlichen Motoren sind. Die Dateien, die ausführliche Informationen zum Einzelteil 1, 2, 3, 7 und 9 enthalten, haben so ein Format, dass es keine entsprechende Funktion gibt, die nach dem Einlesen unmittelbar aus dem original Format eine übersichtliche Struktur erzeugen würde. Deswegen werden die Dateien auf die folgende Weise modifiziert. Die Data in der Dateien werden in übersichtliche Zeile nach der Analysierung ihrer Struktur organisiert und die Field Parameters werden simplifiziert, was es ermöglicht, die Dateien durch eine Funktion wie Fread einzulesen, um eine Data Frame zu erzeugen. 

*Einzelteil 01*

```{r Einzelteil_01, message = FALSE, warning = FALSE}
# die Daten im Einzelteil_T01.txt habe fogende Merkmal:
#   -die 2. Spalt von Oberservation ist überschüssig , 3. Spalt ist  die echte ID_T01
#   -Trennzeichen zwischen Spalten ist  " | | " , und in  ASCII(hex) ist \x20\x7c\x20\x7c\x20 
#   -Trennzeichen zwischen Zeilen ist " "(einzel Leerzeichen) und in  ASCII(hex) ist \x20
#
#Fehler :
#   -Zeichen "Fahrleistung" und  "A" ist Bestandteil von Datensatz (NA), bitte vermeiden sie als Pattern zu nutzen 
#   -bei ersetzen durch "str_replace_all" hast du falsch Pattern genutzt. einstellige Pipeline "|" bedeutet logische operation "Oder", das Zeichen "\" kann wörtliche Bedeutung einer Stelle nutzen. deswegen die richtige Format von " | | "ist  " \\| \\| "

Einzelteil_T01 <- read_file("Data/Einzelteil/Einzelteil_T01.txt") %>%
  str_replace_all(" \\| \\| " , ",") %>%
  str_replace_all(" ", "\n")%>%
  # str_replace_all(regex(",\\d{3,},\""), ",\"" )%>%    #eliminieren überschüssige Spalte(2. Spalte)
  fread()

```
 
*Einzelteil 02*

```{r Einzelteil_T02, message = FALSE, warning = FALSE}

Einzelteil_T02 <- read_file("Data/Einzelteil/Einzelteil_T02.txt") %>%
  str_replace_all("\t","\n") %>%
  str_replace_all("  ",",") %>%
  # str_replace_all(regex(",\\d{1,},\""), ",\"" )%>%    #eliminieren überschüssige Spalte(2. Spalte)
  fread()

```

*Einzelteil 03*

```{r Einzelteil_T03, message = FALSE, warning = FALSE}
# die unsichtbare Zeichen hat ASCII-Code \x0b  ,ist vertical tab
# das reserviert Zeichen "|" soll interperiert als normaler Zeichen  

Einzelteil_T03 <- read_file("Data/Einzelteil/Einzelteil_T03.txt") %>%
  str_replace_all("\\|",",") %>%
  str_replace_all("\x0b","\n") %>%
  fread()

#   str_replace_all("","\n") %>%
#   fread(sep="|")
# 
# # Ich weiss nicht, warum dieser Code in meinem Computer nicht läuft. 
#   str_replace_all("[|]",",") %>%
#   str_replace_all("","\n") %>%
#   fread()

```
 
*Einzelteil 04 - 06* 

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Einzelteil_T04_5_6, message = FALSE, warning = FALSE}

Einzelteil_T04 <- fread("Data/Einzelteil/Einzelteil_T04.csv")
Einzelteil_T05 <- fread("Data/Einzelteil/Einzelteil_T05.csv")
Einzelteil_T06 <- fread("Data/Einzelteil/Einzelteil_T06.csv")

```

*Einzelteil 07*

```{r Einzelteil_T07, message = FALSE, warning = FALSE}

# Trennzeich zwischen Zeilen korrigiert werden
Einzelteil_T07 <- read_file("Data/Einzelteil/Einzelteil_T07.txt") %>%
  str_replace_all("\"\"","\"\n\"") %>%
  #write_file("test6.txt")
  fread(sep="\t")

```

*Einzelteil 08* 

Dank des Formats dieser Datei kann sie einfach durch fread eingelesen werden.

```{r Einzelteil_T08, message = FALSE, warning = FALSE}

Einzelteil_T08 <- fread("Data/Einzelteil/Einzelteil_T08.csv")

```

*Einzelteil 09*

```{r Einzelteil_T09, message = FALSE, warning = FALSE}
#\v für ASCII-Code \x0b
Einzelteil_T09 <- read_file("Data/Einzelteil/Einzelteil_T09.txt") %>%
  str_replace_all("\v","\n") %>%
  fread(sep="\\")
  # write_file(Einzelteil_T09, path ="Data/Einzelteil/D.txt")

```

*Einzelteil 10*

Dank des Formats dieser Datei kann sie einfach durch fread eingelesen werden.

```{r Einzelteil_T10, message = FALSE, warning = FALSE}

Einzelteil_T10 <- fread("Data/Einzelteil/Einzelteil_T10.csv")

```


**Fahrzeuge und ihre Bestandteile**

*Fahrzeug 11*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Fahrzeug_11, message = FALSE, warning = FALSE}

Fahrzeuge_OEM1_Typ11 <- fread("Data/Fahrzeug/Fahrzeuge_OEM1_Typ11.csv")
Bestandteile_Fahrzeuge_OEM1_Typ11 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ11.csv")

```

*Fahrzeug 12*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Fahrzeug_12, message = FALSE, warning = FALSE}

Fahrzeuge_OEM1_Typ12 <- fread("Data/Fahrzeug/Fahrzeuge_OEM1_Typ12.csv")
Bestandteile_Fahrzeuge_OEM1_Typ12 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ12.csv")

```

*Fahrzeug 21*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Fahrzeug_21, message = FALSE, warning = FALSE}

Fahrzeuge_OEM2_Typ21 <- fread("Data/Fahrzeug/Fahrzeuge_OEM2_Typ21.csv")
Bestandteile_Fahrzeuge_OEM2_Typ21 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM2_Typ21.csv")

```

*Fahrzeug 22*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Fahrzeug_22, message = FALSE, warning = FALSE}

Fahrzeuge_OEM2_Typ22 <- fread("Data/Fahrzeug/Fahrzeuge_OEM2_Typ22.csv")
Bestandteile_Fahrzeuge_OEM2_Typ22 <- fread("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM2_Typ22.csv")

```


**Komponente(Motoren) und ihre Bestandteile**

*Motor K1BE1*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Motor_K1BE1, message = FALSE, warning = FALSE}

Komponente_K1BE1 <- fread("Data/Komponente/Komponente_K1BE1.csv")
Bestandteile_Komponente_K1BE1 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K1BE1.csv")

```

*Motor K1BE2*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Motor_K1BE2, message = FALSE, warning = FALSE}

Komponente_K1BE2 <- fread("Data/Komponente/Komponente_K1BE2.csv")
Bestandteile_Komponente_K1BE2 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K1BE2.csv")

```

*Motor K1DI1*

Dank des Formats dieser Dateien können sie einfach durch fread eingelesen werden.

```{r Motor_K1DI1, message = FALSE, warning = FALSE}

Komponente_K1DI1 <- fread("Data/Komponente/Komponente_K1DI1.csv")
Bestandteile_Komponente_K1DI1 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K1DI1.csv")

```

*Motor K1DI2*

Folgende Datei wird so modifiziert, dass eine einlesbare Struktur generiert wird, mit der eine Funktion wie Fread eine Data Frame erstellen kann. 

```{r Motor_K1DI2_1, message = FALSE, warning = FALSE}

#Spalte V1 ist wiederholend zu X1
Komponente_K1DI2 <- read_file("Data/Komponente/Komponente_K1DI2.txt") %>%
  str_replace_all("\t","\n") %>%
  fread(sep="\\")

```

Dank des Formats folgender Datei kann sie einfach durch fread eingelesen werden.

```{r Motor_K1DI2_2, message = FALSE, warning = FALSE}

Bestandteile_Komponente_K1DI2 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K1DI2.csv")

```


**Zulassungen**

Dank des Formats dieser Datei kann sie einfach durch fread eingelesen werden.

```{r Zulassungen, message = FALSE, warning = FALSE}

Zulassungen_alle_Fahrzeuge <- read_csv2("Data/Zulassungen/Zulassungen_alle_Fahrzeuge.csv")

```

# Datenaufbereitung

Die durch die Importierung resultierenden Datensätze enthalten mehrere Variablen, die völlig irrelevant bezüglich des Zieles der CaseStudy sind, so wie Spalten, die nach der Importierung generiert wurden, die überhaupt keine Information haben. Entsprechend werden diese Variablen und Spalten entfernt und das Format der relevanten Variablen geändert, falls notwendig.    

**Funktionen für die Datenaufbereitung**

```{r Function_Datentyp, message = FALSE, warning = FALSE}

# Initiale Aufbereitung bezieht sich auf die Union von Variablen und Entfernung von unnötigen Zeichen je nach Datensatz

# Function für die Anpassung des Datentyps von Variablen nach initialer Aufbereitung

Anpassung_Datentyp <- function(datensatz, ID_Typ) {
  # Ich habe bemerkt, dass der nächste LOC als Kommentar gesetzt wurde. Auf einem ersten Blick scheint dieser LOC unnötig und es ist so für fast alle Fälle. Die Sache ist, dass es einen Datensatz gibt, der  nach der Importierung den ID-type als factor setzt. Diese Variabel sollte meiner Meinung nach charachter sein. Deswegen habe ich diesen LOC hinzugefügt. Man könnte das auch in diesen Einzelfällen außerhalb dieser Funktion tun, aber ich möchte einfach eine Funktion für alle Datensätze benutzen.   
  
  # datensatz[[ID_Typ]] <- type.convert(datensatz[[ID_Typ]])
  
  # datensatz[[ID_Typ]] <- lapply(datensatz[[ID_Typ]], as.character)
  
  # datensatz[[ID_Typ]] <- type.convert(datensatz[[ID_Typ]], as.is = TRUE)
  datensatz$Produktionsdatum <- as.Date(datensatz$Produktionsdatum)
  datensatz$Fehlerhaft_Datum <- as.Date(datensatz$Fehlerhaft_Datum, format="%Y-%m-%d")
  datensatz$Fehlerhaft <- as.integer(as.character(datensatz$Fehlerhaft))
  return(datensatz)
}

# Function für die  Auswahl von relevanten Variablen und Anpassung des Datentyps von Variablen, die keine initiale Aufbereitung brauchen. Außerdem haben die Datensätze, die durch folgende Funktion aufbereitet werden, zwei Variablen bezüglich Origin.

Aufbereitung_des_Datensatz_mit_Origin <- function(datensatz, ID_Typ){
  datensatz <- mutate(datensatz, Produktionsdatum = Produktionsdatum_Origin_01011970 + dmy(origin))
  datensatz <- select(datensatz, c( ID_Typ, "Fehlerhaft", "Fehlerhaft_Datum", "Produktionsdatum"))
  datensatz <- Anpassung_Datentyp(datensatz, ID_Typ)
  return(datensatz)
}

# Function für die Auswahl von relevanten Variablen und Anpassung des Datentyps von Variablen, die keine initiale Aufbereitung brauchen. Außerdem haben die Datensätze, die durch folgende Funktion aufbereitet werden, nur eine Variabel bezüglich Origin. 

Aufbereitung_des_Datensatz_ohne_Origin <- function(datensatz, ID_Typ){
  datensatz <- select(datensatz, c( ID_Typ, "Fehlerhaft", "Fehlerhaft_Datum", "Produktionsdatum"))
  datensatz <- Anpassung_Datentyp(datensatz, ID_Typ)
  return(datensatz)
}

# Function für die mit den Bestandteilen der Fahrzeuge zusammenhängende Auswahl von relevanten Variablen und Anpassung des Datentyps von Variablen, die keine initiale Aufbereitung brauchen 

Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung <- function(datensatz){
  datensatz <- select(datensatz, -X1)
  return(datensatz)
}

# Funktionen für die Anpassung des Datentyps von Variablen des Finalsatzes

## Folgende Funktion stellt sicher, dass die Variablen im Finaldatensatz den richtigen Datentyp haben. 

Anpassung_Datentyp_Final_Datensatz <- function(datensatz) {
  datensatz$Produktionsdatum <- as.Date(datensatz$Produktionsdatum, format="%Y-%m-%d")
  datensatz$Fehlerhaft_Datum <- as.Date(datensatz$Fehlerhaft_Datum, format="%Y-%m-%d")
  datensatz$Fehlerhaft <- as.integer(as.character(datensatz$Fehlerhaft))
  return(datensatz)
}

## Folgende Funktion findet das früheste Datum, an dem ein Einzelteil einer einzelnen Komponente bzw. die einzelne Komponente(Motor)  als fehlerhaft angemeldet wurde. Diese Funktion wird verwendet, weil es einige Komponenten gibt, die mehr als ein Einzelteil haben, die als Fehlerhaft angemeldet wurden. Somit soll das Fehlerhaftdatum das früheste Datum der Daten, an dem ein Fehler angemeldet wurde.      

Anpassung_Datentyp_Final_Datensatz_Fehlerhaft_Datum <- function(datensatz) {
  datensatz$Fehlerhaft_Datum <- apply(datensatz[c("Fehlerhaft_Datum", "Fehlerhaft_Datum_T01", "Fehlerhaft_Datum_T02", "Fehlerhaft_Datum_T03", "Fehlerhaft_Datum_T04", "Fehlerhaft_Datum_T05", "Fehlerhaft_Datum_T06", "Fehlerhaft_Datum_T07", "Fehlerhaft_Datum_T08", "Fehlerhaft_Datum_T09", "Fehlerhaft_Datum_T10")],1,min,na.rm=TRUE) 
  datensatz$Fehlerhaft_Datum <- as.Date(datensatz$Fehlerhaft_Datum, format = "%Y-%m-%d")
  return(datensatz)
}

## Folgende Funktion ersetzt die NAs dieser Variablen, sodass man die Anzahlt von Fehlermeldungen einer einzelnen Komponente addieren kann, um es sicherzustellen, dass man richtig bestimmt, ob eine Komponente fehlerhaft ist.  

Anpassung_Datentyp_Final_Datensatz_Fehlerhaft <- function(datensatz) {
  datensatz$Fehlerhaft[is.na(datensatz$Fehlerhaft)] = 0
  datensatz$Fehlerhaft_T01[is.na(datensatz$Fehlerhaft_T01)] = 0
  datensatz$Fehlerhaft_T02[is.na(datensatz$Fehlerhaft_T02)] = 0
  datensatz$Fehlerhaft_T03[is.na(datensatz$Fehlerhaft_T03)] = 0
  datensatz$Fehlerhaft_T04[is.na(datensatz$Fehlerhaft_T04)] = 0
  datensatz$Fehlerhaft_T05[is.na(datensatz$Fehlerhaft_T05)] = 0
  datensatz$Fehlerhaft_T06[is.na(datensatz$Fehlerhaft_T06)] = 0
  datensatz$Fehlerhaft_T07[is.na(datensatz$Fehlerhaft_T07)] = 0
  datensatz$Fehlerhaft_T08[is.na(datensatz$Fehlerhaft_T08)] = 0
  datensatz$Fehlerhaft_T09[is.na(datensatz$Fehlerhaft_T09)] = 0
  datensatz$Fehlerhaft_T10[is.na(datensatz$Fehlerhaft_T10)] = 0
  return(datensatz)
}

```


**Einzelteile 01 bis 10**

*Einzelteil 01*

```{r Aufbereitung_T01, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T01)

# Änderung der Namen der Spalten, sodass die Werte den richtigen Variablennamen entsprechen

Einzelteil_T01 <- Einzelteil_T01 %>% 
  rename(replace = c(",\"Produktionsdatum.x\"," = "ID_T01.x", ",\"Herstellernummer.x\"," = "Produktionsdatum.x", ",\"Werksnummer.x\"," = "Herstellernummer.x" , ",\"Fehlerhaft.x\"," = "Werksnummer.x", ",\"Fehlerhaft_Datum.x\"," = "Fehlerhaft.x", ",\"Fehlerhaft_Fahrleistung.x\"," = "Fehlerhaft_Datum.x", ",\"ID_T01.y\"," = "Fehlerhaft_Fahrleistung.x", ",\"Produktionsdatum.y\"," = "ID_T01.y", ",\"Herstellernummer.y\"," = "Produktionsdatum.y", ",\"Werksnummer.y\"," = "Herstellernummer.y" , ",\"Fehlerhaft.y\"," = "Werksnummer.y", ",\"Fehlerhaft_Datum.y\"," = "Fehlerhaft.y", ",\"Fehlerhaft_Fahrleistung.y\"," = "Fehlerhaft_Datum.y", ",\"ID_T01\"," = "Fehlerhaft_Fahrleistung.y", ",\"Produktionsdatum\"," = "ID_T01", ",\"Herstellernummer\"," = "Produktionsdatum", ",\"Werksnummer\"," = "Herstellernummer" , ",\"Fehlerhaft\"," = "Werksnummer", ",\"Fehlerhaft_Datum\"," = "Fehlerhaft", ",\"Fehlerhaft_" = "Fehlerhaft_Datum", "V45" = "Fehlerhaft_Fahrleistung")) 

# Auswahl der für die Analyse relevanten Variablen.
 
Einzelteil_T01 <- Einzelteil_T01[,c("ID_T01.x", "ID_T01.y", "ID_T01", "Produktionsdatum.x", "Produktionsdatum.y", "Produktionsdatum", "Fehlerhaft.x", "Fehlerhaft.y", "Fehlerhaft", "Fehlerhaft_Datum.x", "Fehlerhaft_Datum.y", "Fehlerhaft_Datum")]                                                                                                        
# Union von separaten Variablen, die eigentlich die gleiche Information enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variabeln. Der Datensatz wird so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind. 

Einzelteil_T01 <- Einzelteil_T01 %>%
  unite("ID_T01", ID_T01, ID_T01.x, ID_T01.y) %>% 
  unite("Produktionsdatum", Produktionsdatum, Produktionsdatum.x, Produktionsdatum.y) %>%
  unite("Fehlerhaft", Fehlerhaft, Fehlerhaft.x, Fehlerhaft.y) %>%
  unite("Fehlerhaft_Datum", Fehlerhaft_Datum, Fehlerhaft_Datum.x, Fehlerhaft_Datum.y) %>%
  sapply(str_remove_all,"[,\"_NA]") %>%
  as.data.frame() %>%
  Anpassung_Datentyp("ID_T01") %>%
  filter(Fehlerhaft == 1)

```

*Einzelteil 02*

```{r Aufbereitung_T02, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T02)

# Auswahl der für die Analyse relevanten Variablen und Union von separaten Variablen, die eigentlich die gleiche Information enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variabeln. Der Datensatz wird so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.

Einzelteil_T02 <- Einzelteil_T02 %>%
  select(-c("V1", "X1", "Herstellernummer.x", "Werksnummer.x", "Herstellernummer.y", "Werksnummer.y", "Fehlerhaft_Fahrleistung.x", "Fehlerhaft_Fahrleistung.y")) %>%
  unite("ID_T02", ID_T02.x, ID_T02.y) %>% 
  unite("Produktionsdatum", Produktionsdatum.x, Produktionsdatum.y) %>%
  unite("Fehlerhaft", Fehlerhaft.x, Fehlerhaft.y) %>%
  unite("Fehlerhaft_Datum", Fehlerhaft_Datum.x, Fehlerhaft_Datum.y) %>%
  sapply(str_remove_all,"[_NA]") %>%
  as.data.frame() %>%
  Anpassung_Datentyp("ID_T02") %>%
  filter(Fehlerhaft == 1)

```

*Einzelteil 03 und 04*

```{r Aufbereitung_T03_04, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T03)
str(Einzelteil_T04)

# Anwendung von die Datensätze aufbereitender Funktion für die Einzelteile (Details dieser Funktion liegen bei der Definition der Funktion vor). Die Datensätze werden so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.

Einzelteil_T03 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T03, "ID_T03") %>%
  filter(Fehlerhaft == 1)
Einzelteil_T04 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T04, "ID_T04") %>%
  filter(Fehlerhaft == 1)


```

*Einzelteil 05*

```{r Aufbereitung_T05, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T05)

# Auswahl der für die Analyse relevanten Variablen und Union von separaten Variablen, die eigentlich die gleiche Information enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variabeln. Der Datensatz wird so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.


Einzelteil_T05 <- Einzelteil_T05 %>%
  select(-c("V1", "X1", "Herstellernummer.x", "Werksnummer.x", "Herstellernummer.y", "Werksnummer.y", "Fehlerhaft_Fahrleistung.x", "Fehlerhaft_Fahrleistung.y")) %>%
  unite("ID_T05", ID_T05.x, ID_T05.y) %>% 
  unite("Produktionsdatum", Produktionsdatum.x, Produktionsdatum.y) %>%
  unite("Fehlerhaft", Fehlerhaft.x, Fehlerhaft.y) %>%
  unite("Fehlerhaft_Datum", Fehlerhaft_Datum.x, Fehlerhaft_Datum.y) %>%
  sapply(str_remove_all,"[_NA]") %>%
  as.data.frame() %>%
  Anpassung_Datentyp("ID_T05") %>%
  filter(Fehlerhaft == 1)

```

*Einzelteil 06, 07 und 08*

```{r Aufbereitung_T06_07_08, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T06)
str(Einzelteil_T07)
str(Einzelteil_T08)

# Anwendung von die Datensätze aufbereitender Funktion für die Einzelteile (Details dieser Funktion liegen bei der Definition der Funktion vor). Die Datensätze werden so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.

Einzelteil_T06 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T06, "ID_T06") %>%
  filter(Fehlerhaft == 1)
Einzelteil_T07 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T07, "ID_T07") %>%
  filter(Fehlerhaft == 1)
Einzelteil_T08 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T08, "ID_T08") %>%
  filter(Fehlerhaft == 1)

```

*Einzelteil 09*

```{r Aufbereitung_T09, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T09)

# Auswahl der für die Analyse relevanten Variablen und Union von separaten Variablen, die eigentlich die gleiche Information enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variabeln. Der Datensatz wird so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.


Einzelteil_T09 <- Einzelteil_T09 %>%
  select(-c("V1", "X1", "Herstellernummer.x", "Werksnummer.x", "Herstellernummer.y", "Werksnummer.y", "Fehlerhaft_Fahrleistung.x", "Fehlerhaft_Fahrleistung.y")) %>%
  unite("ID_T09", ID_T09.x, ID_T09.y) %>% 
  unite("Produktionsdatum", Produktionsdatum.x, Produktionsdatum.y) %>%
  unite("Fehlerhaft", Fehlerhaft.x, Fehlerhaft.y) %>%
  unite("Fehlerhaft_Datum", Fehlerhaft_Datum.x, Fehlerhaft_Datum.y) %>%
  sapply(str_remove_all,"[_NA]") %>%
  as.data.frame() %>%
  Anpassung_Datentyp("ID_T09") %>%
  filter(Fehlerhaft == 1)

```

*Einzelteil 10*

```{r Aufbereitung_T10, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Einzelteil_T10)

# Anwendung von die Datensätze aufbereitender Funktion für die Einzelteile (Details dieser Funktion liegen bei der Definition der Funktion vor). Der Datensatz wird so gefiltert, weil die Informationen von nur fehlerhaften Einzelteilen relevant sind.

Einzelteil_T10 <- Aufbereitung_des_Datensatz_mit_Origin(Einzelteil_T10, "ID_T10") %>%
  filter(Fehlerhaft == 1)

```


**Fahrzeuge und ihre Bestandteile**

*Fahrzeug 11*

```{r Aufbereitung_Fahrzeug_11, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Fahrzeuge_OEM1_Typ11)
str(Bestandteile_Fahrzeuge_OEM1_Typ11)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Fahrzeuge_OEM1_Typ11 <- Aufbereitung_des_Datensatz_ohne_Origin(Fahrzeuge_OEM1_Typ11, "ID_Fahrzeug")
Bestandteile_Fahrzeuge_OEM1_Typ11 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Fahrzeuge_OEM1_Typ11) %>%
  select(-c("ID_Sitze", "ID_Schaltung", "ID_Karosserie"))

```

*Fahrzeug 12*

```{r Aufbereitung_Fahrzeug_12, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Fahrzeuge_OEM1_Typ12)
str(Bestandteile_Fahrzeuge_OEM1_Typ12)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Fahrzeuge_OEM1_Typ12 <- Aufbereitung_des_Datensatz_ohne_Origin(Fahrzeuge_OEM1_Typ12, "ID_Fahrzeug")
Bestandteile_Fahrzeuge_OEM1_Typ12 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Fahrzeuge_OEM1_Typ12) %>%
  select(-c("ID_Sitze", "ID_Schaltung", "ID_Karosserie"))

```

*Fahrzeug 21*

```{r Aufbereitung_Fahrzeug_21, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Fahrzeuge_OEM2_Typ21)
str(Bestandteile_Fahrzeuge_OEM2_Typ21)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Fahrzeuge_OEM2_Typ21 <- Aufbereitung_des_Datensatz_mit_Origin(Fahrzeuge_OEM2_Typ21, "ID_Fahrzeug")
Bestandteile_Fahrzeuge_OEM2_Typ21 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Fahrzeuge_OEM2_Typ21) %>%
  select(-c("ID_Sitze", "ID_Schaltung", "ID_Karosserie"))

```

*Fahrzeug 22*

```{r Aufbereitung_Fahrzeug_22, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Fahrzeuge_OEM2_Typ22)
str(Bestandteile_Fahrzeuge_OEM2_Typ22)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Fahrzeuge_OEM2_Typ22 <- Aufbereitung_des_Datensatz_mit_Origin(Fahrzeuge_OEM2_Typ22, "ID_Fahrzeug")
Bestandteile_Fahrzeuge_OEM2_Typ22 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Fahrzeuge_OEM2_Typ22) %>%
  select(-c("ID_Sitze", "ID_Schaltung", "ID_Karosserie"))

```


**Komponente und ihre Bestandteile**

*Motor K1BE1*

```{r Aufbereitung_Motor_K1BE1, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Komponente_K1BE1)
str(Bestandteile_Komponente_K1BE1)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Komponente_K1BE1 <- Aufbereitung_des_Datensatz_mit_Origin(Komponente_K1BE1, "ID_Motor")
Bestandteile_Komponente_K1BE1 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Komponente_K1BE1)

```

*Motor K1BE2*

```{r Aufbereitung_Motor_K1BE2, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Komponente_K1BE2)
str(Bestandteile_Komponente_K1BE2)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Komponente_K1BE2 <- Aufbereitung_des_Datensatz_mit_Origin(Komponente_K1BE2, "ID_Motor")
Bestandteile_Komponente_K1BE2 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Komponente_K1BE2)

```

*Motor K1DI1*

```{r Aufbereitung_Motor_K1DI1, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Komponente_K1DI1)
str(Bestandteile_Komponente_K1DI1)

# Auswahl der für die Analyse relevanten Variablen und Union von separaten Variablen, die eigentlich die gleiche Information enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variabeln

Komponente_K1DI1 <- Komponente_K1DI1 %>%
  select(-c("V1", "X1", "Herstellernummer", "Werksnummer", "Fehlerhaft_Fahrleistung", "Herstellernummer.x", "Werksnummer.x", "Herstellernummer.y", "Werksnummer.y", "Fehlerhaft_Fahrleistung.x", "Fehlerhaft_Fahrleistung.y")) %>%
  unite("ID_Motor", ID_Motor, ID_Motor.x, ID_Motor.y) %>% 
  unite("Produktionsdatum", Produktionsdatum, Produktionsdatum.x, Produktionsdatum.y) %>%
  unite("Fehlerhaft", Fehlerhaft, Fehlerhaft.x, Fehlerhaft.y) %>%
  unite("Fehlerhaft_Datum", Fehlerhaft_Datum, Fehlerhaft_Datum.x, Fehlerhaft_Datum.y) %>%
  sapply(str_remove_all,"[,\"_NA]") %>%
  as.data.frame() %>%
  Anpassung_Datentyp("ID_Motor")

# Anwendung von die Datensätze aufbereitender Funktion (Details dieser Funktion liegen bei der Definition der Funktion vor)

Bestandteile_Komponente_K1DI1 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Komponente_K1DI1)

```

*Motor K1DI2*

```{r Aufbereitung_Motor_K1DI2, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Komponente_K1DI2)
str(Bestandteile_Komponente_K1DI2)

# Anwendung von die Datensätze aufbereitenden Funktionen (Details dieser Funktion liegen bei der Definition der Funktion vor)

Komponente_K1DI2 <- Aufbereitung_des_Datensatz_mit_Origin(Komponente_K1DI2, "ID_Motor")
Bestandteile_Komponente_K1DI2 <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Bestandteile_Komponente_K1DI2)

```


**Zulassungen**

```{r Aufbereitung_Zulassung, message = FALSE, warning = FALSE}

# Blick auf Struktur des Datensatzes  

str(Zulassungen_alle_Fahrzeuge)

# Anwendung von die Datensätze aufbereitender Funktion (Details dieser Funktion liegen bei der Definition der Funktion vor)

Zulassungen_alle_Fahrzeuge <- Aufbereitung_des_Datensatz_Bestandteile_bzw_Zulassung(Zulassungen_alle_Fahrzeuge)

```

# Erstellen des finalen Datensatzes

Zuerst erstellen wir eine Dataframe, die alle die Identifikationsnummer der Motoren hat. Dann verbinden wir alle die Motoren mit ihren Bestandteilen. Die anderen Schritte werden nach jedem LOC erklärt, um den Code übersichtlicher zu machen.   

```{r Dataframe_alle_Motoren, message = FALSE, warning = FALSE}

# Vertikale Verbindung von Dataframes der Komponente(Motoren)

Final_Datensatz <- rbind(Komponente_K1BE1, Komponente_K1BE2, Komponente_K1DI1, Komponente_K1DI2) %>%

  # Verbindung der Motoren mit ihren Bestandteilen

  left_join(Bestandteile_Komponente_K1BE1, by = c("ID_Motor" = "ID_K1BE1")) %>%
  left_join(Bestandteile_Komponente_K1BE2, by = c("ID_Motor" = "ID_K1BE2")) %>%
  left_join(Bestandteile_Komponente_K1DI1, by = c("ID_Motor" = "ID_K1DI1")) %>%
  left_join(Bestandteile_Komponente_K1DI2, by = c("ID_Motor" = "ID_K1DI2")) %>%
  
  # Verbindung von Variablen, die die gleiche Information bezüglich eines Einzelteiles enthalten, sowie   # die Entfernung von unnötigen Zeichen innerhalb dieser Variablen. (Details der verwendeten Funktion    # liegen bei der Definition der Funktion vor)   
    
  unite("ID_T1", ID_T1.x, ID_T1.y, ID_T1.x.x, ID_T1.y.y) %>%
  unite("ID_T2", ID_T2.x, ID_T2.y, ID_T2.x.x, ID_T2.y.y) %>%
  modify(str_remove_all,"[,\"_NA]") %>%
  Anpassung_Datentyp_Final_Datensatz() %>%

  # Verbindung von Einzelteilen mit ihren Fehlermeldungs- und Produktionsdaten. (Details der verwendeten   # Funktion liegen bei der Definition der Funktion vor) 
  
  left_join(Einzelteil_T01, by = c("ID_T1" = "ID_T01"), suffix = c("","_T01")) %>%
  left_join(Einzelteil_T02, by = c("ID_T2" = "ID_T02"), suffix = c("","_T02")) %>%
  left_join(Einzelteil_T03, by = c("ID_T3" = "ID_T03"), suffix = c("","_T03")) %>%
  left_join(Einzelteil_T04, by = c("ID_T4" = "ID_T04"), suffix = c("","_T04")) %>%
  left_join(Einzelteil_T05, by = c("ID_T5" = "ID_T05"), suffix = c("","_T05")) %>%
  left_join(Einzelteil_T06, by = c("ID_T6" = "ID_T06"), suffix = c("","_T06")) %>%
  left_join(Einzelteil_T07, by = c("ID_T7" = "ID_T07"), suffix = c("","_T07")) %>%
  left_join(Einzelteil_T08, by = c("ID_T8" = "ID_T08"), suffix = c("","_T08")) %>%
  left_join(Einzelteil_T09, by = c("ID_T9" = "ID_T09"), suffix = c("","_T09")) %>%
  left_join(Einzelteil_T10, by = c("ID_T10"), suffix = c("","_T10")) %>%
  Anpassung_Datentyp_Final_Datensatz_Fehlerhaft() %>% 

  # Zählung der Anzahl von Fehlermeldungen aller einzelnen Komponente und ihrer Bestandteile/Einzelteile   # zur Gewährleistung dessen, dass man richtig bestimmt, ob eine Komponente fehlerhaft ist.  
  
  mutate(Fehlerhaft = Fehlerhaft + Fehlerhaft_T01 + Fehlerhaft_T02 + Fehlerhaft_T03 + Fehlerhaft_T04 + Fehlerhaft_T05 + Fehlerhaft_T06 + Fehlerhaft_T07 + Fehlerhaft_T08 + Fehlerhaft_T09 + Fehlerhaft_T10) %>%
  mutate(Fehlerhaft = ifelse(Fehlerhaft >= 1,1,0)) %>%
  mutate(Fehlerhaft = as.factor(Fehlerhaft)) %>%

  # Entfernung von Variablen, die nicht relevant für die Fortsetzung des Erstellens des Finaldatensatzes
  # sind.(Details der verwendeten   # Funktion liegen bei der Definition der Funktion vor) 
  
  select(-c("Fehlerhaft_T01", "Fehlerhaft_T02", "Fehlerhaft_T03", "Fehlerhaft_T04", "Fehlerhaft_T05", "Fehlerhaft_T06", "Fehlerhaft_T07", "Fehlerhaft_T08", "Fehlerhaft_T09", "Fehlerhaft_T10")) %>%
  select(-c("ID_T1", "ID_T2", "ID_T3", "ID_T4", "ID_T5", "ID_T6", "ID_T7", "ID_T8", "ID_T9", "ID_T10")) %>%
  select(-c("Produktionsdatum_T01", "Produktionsdatum_T02", "Produktionsdatum_T03", "Produktionsdatum_T04", "Produktionsdatum_T05", "Produktionsdatum_T06", "Produktionsdatum_T07", "Produktionsdatum_T08", "Produktionsdatum_T09", "Produktionsdatum_T10")) %>%
  Anpassung_Datentyp_Final_Datensatz_Fehlerhaft_Datum() %>%
  select(-c("Fehlerhaft_Datum_T01", "Fehlerhaft_Datum_T02", "Fehlerhaft_Datum_T03", "Fehlerhaft_Datum_T04", "Fehlerhaft_Datum_T05", "Fehlerhaft_Datum_T06", "Fehlerhaft_Datum_T07", "Fehlerhaft_Datum_T08", "Fehlerhaft_Datum_T09", "Fehlerhaft_Datum_T10")) %>%
  
  # Verbindung der Motoren mit Informationen über das Fahrzeug (z.B. die Identifikationsnummer des        # Fahrzeuges), in dem sie implementiert sind. 
  
  left_join(Bestandteile_Fahrzeuge_OEM1_Typ11, by = c("ID_Motor")) %>%
  left_join(Bestandteile_Fahrzeuge_OEM1_Typ12, by = c("ID_Motor"), suffix = c("","_OEM1_Typ12")) %>%
  left_join(Bestandteile_Fahrzeuge_OEM2_Typ21, by = c("ID_Motor"), suffix = c("","_OEM2_Typ21")) %>%
  left_join(Bestandteile_Fahrzeuge_OEM2_Typ22, by = c("ID_Motor"), suffix = c("","_OEM2_Typ22")) %>%
  
  # Verbindung von Variablen, die die gleiche Information bezüglich einer Identifikationsnummer eines     # Fahrzeuges enthalten, sowie die Entfernung von unnötigen Zeichen innerhalb dieser Variablen. 
  
  unite("ID_Fahrzeug", ID_Fahrzeug, ID_Fahrzeug_OEM1_Typ12, ID_Fahrzeug_OEM2_Typ21, ID_Fahrzeug_OEM2_Typ22) %>%
  modify(str_remove_all,"[,\"_NA]") %>%

  # Verbindung der Identifikationsnummer der Fahrzeugen mit ihrem Zulassungsdatum und Entfernung von      # irrelevante Variablen 
  
  left_join(Zulassungen_alle_Fahrzeuge, by = c("ID_Fahrzeug" = "IDNummer")) %>%
  select(-c("Gemeinden")) %>%
  
  # Berechnung des Lebensdauers jedes Fahrzeuges 
  
  mutate(Fehlerhaft_Datum = as.Date(Fehlerhaft_Datum, format = "%Y-%m-%d")) %>%
  mutate(Fehlerhaft = as.factor(Fehlerhaft)) %>%
  mutate(Lebensdauer_in_Days = Fehlerhaft_Datum - Zulassung)

```                     



# Auswertung 

```{r}

``` 

# Ergebnis

```{r}
# a<- data.frame(b=c(1, 2, 3),c=c(1, 2, 3),d=c(1, 2, 3)) %>%
#   mutate(h=apply(a[c("b","d")],1,min))
  

```